// Copyright (c) 2016 IBM Corp. All rights reserved.
// Use of this source code is governed by the Apache License,
// Version 2.0, a copy of which can be found in the LICENSE file.

var WebSocketServer = require('websocket').server;

var http = require('http');
var serveStatic = require('serve-static')
var finalhandler = require('finalhandler')
var winston = require('winston');

//Ws functions
var sendUnknownType = require('./src/room/sendUnknownType.js');
var prepareChatMessage = require('./src/room/prepareChatMessage.js');
var prepareGoodbyeMessage = require('./src/room/prepareGoodbyeMessage.js');
var sendInventory = require('./src/room/sendInventory.js');
var sendExamine = require('./src/room/sendExamine.js');
var parseGoCommand = require('./src/room/parseGoCommand.js');
var sendUnknownCommand = require('./src/room/sendUnknownCommand.js');

// Room Details
// Your room's name
var theRoomName = (process.env.ROOM_NAME || '');
var fullName = (process.env.FULL_NAME || '');
var description = (process.env.DESCRIPTION || 'This room is filled with little JavaScripts running around everywhere and a monster');

// The hostname of your CF application
var vcapApplication = (process.env.VCAP_APPLICATION || '{}');

// Automatically retrieves the port of your CF
var port = (process.env.CF_INSTANCE_PORT || 3000);
var appUris = (JSON.parse(vcapApplication).application_uris || ['localhost:'+port]);
var endpointip = appUris[0];

var logger = new winston.Logger({
    level: 'debug',
    transports: [
        new(winston.transports.Console)(),
        new(winston.transports.File)({
            filename: './access.log'
        })
    ]
});

// Serve up public folder
var serve = serveStatic('public')

//Serve up static files (index page & supporting CLI-side JS)
var httpServer = http.createServer(function(req, res) {
  if (req.url === '/health') {
      res.writeHead(200);
      res.end("OK");
  } else {
      serve(req, res, finalhandler(req, res, {onerror: logerror}));
  }

}).listen(port);

function logerror (err) {
  console.error(err.stack || err.toString())
}

//Create websocket
var wsServer = new WebSocketServer({
    httpServer: httpServer,
    autoAcceptConnections: false
});

function originIsAllowed(origin) {
    // Logic to determine if this origin is allowed
    // Consider using the secure key generated by Game On! to
    // validate that incoming requests are from Game On!
    // https://gameontext.gitbooks.io/gameon-gitbook/content/microservices/ApplicationSecurity.html#_signed_requests
    return true;
}

wsServer.on('request', function(request) {
    if (!originIsAllowed(request.origin)) {
        // Only accept requests from allowed origins
        request.reject();
        logger.debug("Connection from origin " + request.origin + "rejected.");
        return;
    };
    var conn = request.accept();
    conn.on('message', function(message) {
        if (message.type === 'utf8') {
            var incoming = message.utf8Data;
            logger.debug("RECEIVED: " + incoming)
            var typeEnd = incoming.indexOf(',')
            var targetEnd = incoming.indexOf(',', typeEnd + 1)

            var messageType = incoming.substr(0, typeEnd)
            console.log("MessageType is " + messageType);
            var target = incoming.substr(typeEnd + 1, targetEnd - typeEnd - 1)
            var objectStr = incoming.substr(targetEnd + 1)
            var object = {}
            try {
                object = JSON.parse(objectStr)
            } catch (err) {
                logger.error("Got improper json: " + objectStr)
            }

            logger.info("Parsed a message of type \"" + messageType + "\" sent to target \"" + target + "\".")

            //if (target != theRoomName)
            //  return

            if (messageType === "roomHello") {
                logger.debug("In roomHello")
                sayHello(conn, object.userId, object.username)
            } else if (messageType === "room") {
                if (object.content.indexOf('/') == 0) {
                    parseCommand(conn, object.userId, object.username, object.content)
                } else {
                    logger.info(object.username + " sent chat message \"" + object.content + "\"")
                    broadcast(prepareChatMessage(conn, object.username, object.content));
                }
            } else if (messageType === "roomGoodbye") {
                logger.debug("Announcing that \"" + object.username + "\" has left the room.")
                broadcast(prepareGoodbyeMessage(conn, object.userId, object.username))
            } else {
                sendUnknownType(conn, object.userId, object.username, messageType, logger);
            }
        }
    });
    conn.on("close", function(code, reason) {
            logger.debug("Connection closed.")
    });
});

// Install a special handler to make sure ctrl-c on the command line stops the container
process.on('SIGINT', function() {
    logger.info("The server is exiting");
    wsServer.shutDown();
    process.exit(0);
});

function parseCommand(conn, target, username, content) {
    if (content.substr(1, 3) == "go ") {
        parseGoCommand(conn, target, username, content, registration.doors, logger);
    }
    /*else if (content.substr(1, 5) == "exits")
    {
      sendExits(conn, target, username)
    }
    else if (content.substr(1, 4) == "help")
    {
      sendHelp(conn, target, username)
    }
    else if (content.substr(1, 9) == "inventory")
    {
      sendInventory(conn, target, username, logger)
    }*/
    else if (content.substr(1, 7) == "examine") {
        sendExamine(conn, target, username, logger);
    } else {
        sendUnknownCommand(conn, target, content, logger);
    }
}

function sayHello(conn, target, username) {
    logger.info("Saying hello to \"" + target + "\"")
    var responseObject = {
        "type": "location",
        "name": theRoomName,
        "fullName": fullName,
        "description": description,
    }

    var sendMessageType = "player"
    var sendTarget = target

    var messageText = sendMessageType + "," +
        sendTarget + "," +
        JSON.stringify(responseObject)

    conn.sendUTF(messageText)

    logger.debug("And announcing that \"" + username + "\" has arrived.")
    var broadcastMessageType = "player"
    var broadcastMessageTarget = "*"
    var broadcastMessageObject = {
        type: "event",
        content: {
            "*": username + " enters the room."
        },
        bookmark: 51
    }
    var broadcastMessage = broadcastMessageType + "," +
        broadcastMessageTarget + "," +
        JSON.stringify(broadcastMessageObject)

    broadcast(broadcastMessage)
}

function broadcast(message) {
    wsServer.connections.forEach(function(conn) {
        conn.sendUTF(message)
    })
}

process.on('uncaughtException', function(err) {
    // handle the error safely
    console.log("UNCAUGHT EXCEPTION! " + err)
})

logger.info("The HTTP server is listening on port " + port)
logger.info("The WebSocket server is listening on port " + port)
